# Metasploit


## Шаблон проектування використаний в Metasploit
Metasploit використовує шаблон шаблон **Фасад** який інкапсулює, спрощує всі складні частини фреймворку, реалізуючи його в вигляді інтерфейсів, що робить розробку дуже простою та елегантною.
Я думаю, що приклад фасаду на [Вікіпедії][1] гарно це ілюструє:

```ruby
# Complex Parts | Computer framework 
class CPU 
  def freeze; end
  def jump(position); end
  def execute; end
end

class Memory
  def load(position, data); end
end

class HardDrive
  def read(lba, size); end
end

# Facade | Interface
class ComputerFacade

  def initialize
    @processor = CPU.new
    @ram = Memory.new
    @hd  = HardDrive.new
  end

  def start
    @processor.freeze
    @ram.load(BOOT_ADDRESS, @hd.read(BOOT_SECTOR, SECTOR_SIZE))
    @processor.jump(BOOT_ADDRESS)
    @processor.execute
  end
end

# Client (The Developer want to use the complex computer framework)
computer_facade = ComputerFacade.new
computer_facade.start
```

Як видно з вищенаведеного коду, розробник, якому треба використати наведений **Computer framework** не має необхідності працювати напряму зі складною кодовою базою(класами, методами та іншим). Замість цього, він використа простий клас інтерфейсу під назвою **`ComputerFacade`** що презентуватиме(в вигляді об'єкту) всі класи коли ви викличете його.


Інший приклад в самій мові рубі - це стандартна бібіліотека `open-uri`, яка інкапсулює бібліотеки `net/http` та `uri` так, що вони виглядають як звичайні файли.
Щоб побачити, як `open-uri` спрощує життя, ми напишемо код, який відправляє GET запит до *Ruby.net* та отримує відповідь стандартним методом та за допомогою `open-uri`.


**Стандартний метод**
```ruby
require 'net/http'
require 'uri'

url = URI.parse('http://rubyfu.net')

res = Net::HTTP.start(url.host, url.port) {|http|
  http.get('/content/index.html')
}

puts res.body
```

**В вигляді фасаду**

```ruby
require "open-uri"

puts open("http://rubyfu.net/content/index.html").read
```
Більше про шаблон Фасад можна прочитати тут:
- [Practicingruby | Structural Design Patterns][2]
- [Wikipedia| Facade Pattern#Ruby][3]
- [Sourcemaking | Facade Design Pattern][4]

## Структура фреймворку Metasploit 

![](MSF-struct.png)

Як бачите на малюнку вище, бібліотеки Metasploit працюють як інтерфейс, що надає доступ до всіх модулей, інтерфейсів, інструментів та плагінів. Це точно репрезентує те, про що ми розповіли іише в частині **Шаблон проектування використаний в Metasploit**.


```bash
 mkdir -p $HOME/.msf4/modules/{auxiliary,exploits,post}
```



## Absolute module 
Here is a very basic structure of a general module. 

I'll Add some comments for explanation purpose.


```ruby
##
# This module requires Metasploit: http://www.metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

### Module Type ###
class Metasploit3 < Msf::Exploit::Remote
####################

### Module Requirements ###
include Exploit::Remote::Tcp
####################

### Exploit Rank ####
  Rank = ExcellentRanking
####################

### Module Information
  def initialize(info = {})
    super(update_info(
      info,
      'Name'            => 'Absolute MSF template',
      'Description'     => %q{This is an absolute MSF template that shows how all modules look like},
      'License'         => MSF_LICENSE,
      'Author'          =>
        [
          'Rubyfu (@Rubyfu)',
          'Sabri (@KINGSABRI)'
        ],
      'References'      =>
        [
          ['URL', 'http://Rubyfu.net'],
          ['URL', 'https://github.com/Rubyfu']
        ],
      'Platform'        => %w{ linux win osx solaris unix bsd android aix},
      'Targets'         =>
        [
            ['Universal', {}]
        ],
      'DefaultTarget'  => 0,
      'DisclosureDate'  => '2015'
    ))

    # Module Options | show options
    register_options(
      [
          Opt::RPORT(22),
          OptString.new('USER', [ true, 'Valid username', 'admin' ]),
          OptString.new('PASS', [ true, 'Valid password for username', 'P@ssw0rd' ]),
      ], self.class)

    # Module Advanced Options | show advanced
    register_advanced_options(
      [
          OptInt.new('THREADS', [true, 'The number of concurrent threads', 5])
      ], self.class)
  end
####################


### Module Operations ###
  def exploit # or 'run' for post and auxiliary modules
    print_status('Starting Rubyfu')
    print_warning("It's just a template.")
    print_good('Ruby goes evil!')
    print_error("Thank you!")
  end
####################


end

```

The result is

![](msf_template1.png)




### Load Metasploit module

To load/reload the Metasploit module you're working on, you can put the script in your user's Metasploit path or in the Metasploit framework path 

- User's Metasploit path
```
~/msf4/modules
```

- Metasploit framework path
```
metasploit-framework/modules/
```

To make Metasploit load/reload the script use one of the following ways

- Exit from msfconsole then run it again
- use `reload_all` to reload all modules
- If your module is previously loaded and you made changes on it just use `reload` but you have to be using the module, in another work `use [YOUR MODULE]`


**Note:** It's really important to know the official Metasploit development documentation **(** http://www.rubydoc.info/github/rapid7/metasploit-framework/ **)**

<!---
https://www.exploit-db.com/docs/27935.pdf
http://www.rubydoc.info/github/rapid7/metasploit-framework
https://github.com/rapid7/metasploit-framework/wiki/Exploit-Ranking
https://github.com/rapid7/metasploit-framework/wiki
https://community.rapid7.com/thread/3126
https://github.com/rapid7/metasploit-framework/wiki/Creating-Metasploit-Framework-LoginScanners
-->




<br><br><br>
---
[1]: https://en.wikipedia.org/wiki/Facade_pattern#Ruby
[2]: https://practicingruby.com/articles/structural-design-patterns
[3]: https://en.wikipedia.org/wiki/Facade_pattern#Ruby
[4]: https://sourcemaking.com/design_patterns/facade